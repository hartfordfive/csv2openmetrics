package generator

import (
	"bufio"
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"os"
	"regexp"
	"strconv"
)

type Generator struct {
	Config *CsvMappingConfg
}

func New(configFile string) (*Generator, error) {
	conf := newMappingConfig(configFile)
	g := &Generator{
		Config: conf,
	}
	return g, nil
}

/*

# HELP http_requests_total The total number of HTTP requests.
# TYPE http_requests_total counter
http_requests_total{code="200",service="user"} 123 1609954636
http_requests_total{code="500",service="user"} 456 1609954730
# EOF

*/

func getNamedMatcheds(regex, data string) map[string]string {

	var compRegEx = regexp.MustCompile(regex)
	match := compRegEx.FindStringSubmatch(data)

	matches := make(map[string]string)
	for i, name := range compRegEx.SubexpNames() {
		if i > 0 && i <= len(match) && len(match[i]) >= 1 && len(name) >= 1 {
			matches[name] = match[i]
		}
	}
	return matches
}

func (g *Generator) csvRowToOpenMetrics([]string) string {

	return ""
}

func (g *Generator) ConvertToOpenMetricsFormat(fileMapping CsvFile, outputFile string) error {

	// Build the configuration for the field mappings
	//seriesList := []Metric{}
	colMapping := map[int]map[string]string{}
	colValues := map[int]string{}
	colLabels := map[int]string{}

	for i, f := range fileMapping.Fields {
		//fmt.Printf("Field #%d: %s\n", i, f)
		matches := getNamedMatcheds(`(?P<name>[a-zA-Z0-9]+);type=(?P<type>timestamp|label|value)(,val_type=(?P<val_type>gauge|counter))?(,help=(?P<help>[^,]+))?`, f)
		for _, v := range []string{"name", "type"} {
			if _, ok := matches[v]; !ok {
				return fmt.Errorf("[ERROR] The field entry '%s' is missing the '%s' field\n", f, v)
			}
		}

		colMapping[i] = matches

		if colMapping[i]["type"] == "value" {
			colValues[i] = colMapping[i]["name"]
		} else if colMapping[i]["type"] == "label" {
			colLabels[i] = colMapping[i]["name"]
		}

	}

	fmt.Println("Labels: ", colLabels)

	// Now open the CSV file to read
	inFile, err := os.Open(fileMapping.Filename)
	if err != nil {
		log.Fatal("Unable to read csv file "+fileMapping.Filename, err)
	}
	defer inFile.Close()
	r := csv.NewReader(inFile)

	outFile, err := os.Create(outputFile)
	if err != nil {
		log.Fatal(err)
	}
	buffWritter := bufio.NewWriter(outFile)

	//addHelpAndTypeOnce := map[string]sync.Once{}

	rowIndex := 0

	for {

		record, err := r.Read()
		if err == io.EOF {
			break
		}
		//log.Printf("Reading row #%d", rowIndex)
		if err != nil {
			log.Fatal(err)
		}
		if rowIndex == 0 && fileMapping.TitleRow {
			rowIndex += 1
			continue
		}
		fmt.Printf("row: %v\n", record)

		// Generate the lines
		/*
			# HELP metric_name <METRIC_COMMENT>
			# TYPE metric_name <METRIC_TYPE>
			metric_name{lbl1="value1", lbl2="value2"}
		*/

		//helpString := fileMapping.SeriesPrefix
		//colMapping[rowIndex]

		// Go through each column of the record
		/*
			for i, r := range record {

					colMapping := map[int]map[string]string{}
					colValues := map[int]string{}
					labels := map[int]string{}
			}
		*/

		labels := map[string]string{}
		for i, lbl := range colLabels {
			labels[colMapping[i]["name"]] = record[i]
		}

		for colIndex, colName := range colValues {

			metricName := fmt.Sprintf("%s_%s", fileMapping.SeriesPrefix, colName)
			//addHelpAndType := addHelpAndTypeOnce[colName]
			//addHelpAndType.Do(func() {
			if _, err = buffWritter.WriteString(fmt.Sprintf("# HELP %s %s\n", metricName, colMapping[colIndex]["help"])); err != nil {
				log.Printf("[ERROR] Could not write contents to buffered writter: %v", err)
			}
			if _, err = buffWritter.WriteString(fmt.Sprintf("# TYPE %s %s\n", metricName, colMapping[colIndex]["val_type"])); err != nil {
				log.Printf("[ERROR] Could not write contents to buffered writter: %v", err)
			}
			//})

			v, err := strconv.ParseFloat(record[colIndex], 32)
			m := Metric{
				Name:   metricName,
				Labels: labels,
				Value:  v,
			}
			if _, err = buffWritter.WriteString(fmt.Sprintf("%s\n", m.ToString())); err != nil {
				log.Printf("[ERROR] Could not write contents to buffered writter: %v", err)
			}

			// Now add the generated bytes to the buffered writter
			//nBytes, err := buffWritter.WriteString(ln + "\n")

		}
		//buffWritter.Flush()
		rowIndex += 1
	}

	if _, err = buffWritter.WriteString("# EOF\n"); err != nil {
		log.Printf("[ERROR] Could not write contents to buffered writter: %v", err)
	}
	buffWritter.Flush()

	return nil
}
