package generator

import (
	"bufio"
	"encoding/csv"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"sync"
)

type Generator struct {
	Config *CsvMappingConfg
}

func New(configFile string) (*Generator, error) {
	conf := newMappingConfig(configFile)
	g := &Generator{
		Config: conf,
	}
	return g, nil
}

/*

# HELP http_requests_total The total number of HTTP requests.
# TYPE http_requests_total counter
http_requests_total{code="200",service="user"} 123 1609954636
http_requests_total{code="500",service="user"} 456 1609954730
# EOF

*/

func getNamedMatcheds(regex, data string) map[string]string {

	var compRegEx = regexp.MustCompile(regex)
	match := compRegEx.FindStringSubmatch(data)

	matches := make(map[string]string)
	for i, name := range compRegEx.SubexpNames() {
		if i > 0 && i <= len(match) && len(match[i]) >= 1 && len(name) >= 1 {
			matches[name] = match[i]
		}
	}
	return matches
}

func (g *Generator) ConvertToOpenMetricsFormat(fileMapping CsvFile) error {

	// Build the configuration for the field mappings
	colMapping := map[int]map[string]string{}
	colValues := map[int]string{}
	colLabels := map[int]string{}
	var seriesTimestampindex int

	for i, f := range fileMapping.Fields {
		matches := getNamedMatcheds(`(?P<name>[a-zA-Z0-9_]+);type=(?P<type>timestamp|label|value|omit)(,val_type=(?P<val_type>gauge|counter))?(,help=(?P<help>[^,]+))?`, f)
		for _, v := range []string{"name", "type"} {
			if _, ok := matches[v]; !ok {
				return fmt.Errorf("[ERROR] The field entry '%s' is missing the '%s' field\n", f, v)
			}
		}

		colMapping[i] = matches

		if colMapping[i]["type"] == "omit" {
			fmt.Printf("Skipping field '%s'\n", colMapping[i]["name"])
			continue
		} else if colMapping[i]["type"] == "value" {
			colValues[i] = colMapping[i]["name"]
		} else if colMapping[i]["type"] == "label" {
			colLabels[i] = colMapping[i]["name"]
		} else if colMapping[i]["type"] == "timestamp" {
			seriesTimestampindex = i
		}

	}

	// Now open the CSV file to read
	inFile, err := os.Open(fileMapping.Filename)
	if err != nil {
		log.Fatal("Unable to read csv file "+fileMapping.Filename, err)
	}
	defer inFile.Close()
	r := csv.NewReader(inFile)

	// Ensure the output dir exists
	if err := os.Mkdir(fileMapping.OutputDir, 0755); err != nil && !os.IsExist(err) {
		log.Fatal(err)
	}

	// Initialize a buffered writter per metric so that we can set only a single
	buffWriter := map[string]*bufio.Writer{}
	for _, name := range colValues {
		f := filepath.Join(fileMapping.OutputDir, fmt.Sprintf("%s_%s.om", fileMapping.SeriesPrefix, name))
		outFile, err := os.Create(f)
		if err != nil {
			log.Fatal(err)
		}
		buffWriter[name] = bufio.NewWriter(outFile)
	}

	addHelpAndTypeOnce := map[string]sync.Once{}
	for _, name := range colValues {
		addHelpAndTypeOnce[name] = sync.Once{}
	}

	rowIndex := 0

	for {

		record, err := r.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatal(err)
		}
		if rowIndex == 0 && fileMapping.TitleRow {
			rowIndex += 1
			continue
		}
		//fmt.Printf("row: %v\n", record)

		labels := map[string]string{}
		for i, lbl := range colLabels {
			labels[lbl] = record[i]
		}

		for colIndex, colName := range colValues {

			metricName := fmt.Sprintf("%s_%s", fileMapping.SeriesPrefix, colName)
			addHelpAndType := addHelpAndTypeOnce[colName]
			op := &addHelpAndType
			op.Do(func() {
				if _, err = buffWriter[colName].WriteString(fmt.Sprintf("# HELP %s %s\n", metricName, colMapping[colIndex]["help"])); err != nil {
					log.Printf("[ERROR] Could not write contents to buffered writter: %v\n", err)
				}
				if _, err = buffWriter[colName].WriteString(fmt.Sprintf("# TYPE %s %s\n", metricName, colMapping[colIndex]["val_type"])); err != nil {
					log.Printf("[ERROR] Could not write contents to buffered writter: %v\n", err)
				}
			})

			v, err := strconv.ParseFloat(record[colIndex], 32)
			m := Metric{
				Name:      metricName,
				Timestamp: record[seriesTimestampindex],
				Labels:    labels,
				Value:     v,
			}
			if _, err = buffWriter[colName].WriteString(fmt.Sprintf("%s\n", m.ToString())); err != nil {
				log.Printf("[ERROR] Could not write contents to buffered writter: %v\n", err)
			}

			// Now add the generated bytes to the buffered writter
			//nBytes, err := buffWriter[colName].WriteString(ln + "\n")

		}
		//buffWritter.Flush()
		rowIndex += 1
	}

	for _, seriesBuffer := range colValues {
		fmt.Printf("Force flushing buffer for value: %s\n", seriesBuffer)
		if _, err = buffWriter[seriesBuffer].WriteString("# EOF\n"); err != nil {
			log.Printf("[ERROR] Could not write contents to buffered writter: %v\n", err)
		}
		buffWriter[seriesBuffer].Flush()
	}

	return nil
}
